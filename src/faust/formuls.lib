declare author "James Dooley: info@formuls.co.uk";
declare copyright "James Dooley";
declare version "1.0";
declare license "MIT";
declare options "[osc:on]";

import("stdfaust.lib");

//----------------------------------------------------------------------------------------//
//----------------------------------SYNTHESIS---------------------------------------------//
//----------------------------------------------------------------------------------------//
//------fmosc-------//
/* FM Oscillator: sine -> triangle -> sawtooth -> square. */
// o1f = op1 freq, o1sr = op1 slide range, o1st = op1 slide time,o2f = op2 freq, o2d = op2 depth, na = noise, wa = waveshape, ta = trigger
fmosc(o1f,o1sr,o1st,o2f,o2d,na,wa,ta) = freqset : fmosc
  with{
    o1sr1 = o1sr : ba.sAndH(ta : ba.impulsify);
    o1st1 = o1st : ba.sAndH(ta : ba.impulsify);
    ta1 = ta : @(10);
    cf = o1f : +(o1f : *((en.ar(0.001,o1st1,ta1) : pow(2.7)) : *(o1sr1))) : min(19000); //calculate op1 freq during freq slide
    freqcontrol =  cf : +(na) : +(os.oscsin(cf*o2f) : *(cf) : *(o2d)); //where the freq modulation happens
    freqset = _ : *(freqcontrol) : +(freqcontrol);
    clip(x) = x : min(1,_) : max(0,_);
    // oscphase = ta1 == (0) : ba.impulsify;
    wa1 = wa : si.smoo;
    fmosc = _ <: (((os.oscsin), (os.lf_triangle) : si.interpolate(clip(wa1))), (os.lf_saw) : si.interpolate(clip(wa1-(1)))), os.lf_squarewave : si.interpolate(clip(wa1-(2)));
  };

//---------ADSR----------//
/* Fixed duration ADSR envelope for FMSynth module */
adsr(a,d,s,r,t) = _ : *(en.dx7envelope(a1,d1,r1,1,1,s1,0,0,t1) : pow(2.7))
with {
  a1 = a : ba.sAndH(t : ba.impulsify);
  d1 = d : ba.sAndH(t : ba.impulsify);
  s1 = s : ba.sAndH(t : ba.impulsify);
  r1 = r : ba.sAndH(t : ba.impulsify);
  t1 = t : @(2);
};

//----------------------------------------------------------------------------------------//
//----------------------------------AUTOMATION-------------------------------------------//
//----------------------------------------------------------------------------------------//
//-----------AUTOMATION_RECORD---------------//
/* Records incoming  values for automation playback */
// val = value to record into automation; tem = tempo/automation read speed (0-1); rec = start/stop recording (0/1); loo = loop automation; trix = trigger one cycle of recorded automation; act = automation active
automrec(val,tem,rec,loo,trix,act) = _ <: _,memory : ba.selectn(2,act)
with {
  tempo2 = tem : *((ma.SR)/1000) : int; // read value every 1ms
  tableSize = 48000; // with a read periodicity of 1ms, @48kHz SR this creates 48 seconds of memory to record automation to.

  /* calculate the sample duration */
  I = int(rec);		// convert button "Record" signal from float to integer
  R = (I-I') <= 0;		// Reset capture when button is pressed
  D = (+(I):*(R))~_ : ba.sAndH(1-(rec)) : int;		// Compute capture duration while button is pressed: 0..NNNN0..MMM
  D2 = D-(1) : *(tem) : int;

  /* table write and read */
  recindex = (+(1) : *(rec))~_ : _/(tempo2) : *(rec) : int; // records audio to tables below
  counter = ba.countup(D2,trix), ba.sweep(D2,loo) : ba.selectn(2,loo) : /(tempo2) : *(act) : int; // counter to read from the table

  memory = _ <: rwtable(tableSize,0.0,recindex,_,counter), _ : ba.selectn(2,rec) :> si.smoo ; //write and read automation to and from table
  // ADD REVERSE READ FUNCTION
};

//----------------------QUANTISE------------------//
quantise(steps,act) = _ <:_,(_ : *(steps) : rint : /(steps)) : ba.selectn(2,act);

//----------------------------------------------------------------------------------------//
//----------------------------------CHAOS_RANDOM------------------------------------------//
//----------------------------------------------------------------------------------------//
// geneates a random value. can be seeded so you have independent randoms.
randomnoise(freq,seed) = randomx / (RANDMAX) : ba.latch(os.oscrs(freq))
with{
	mask = 4294967295; // 2^32-1
	randomx = +(10000 +(seed)) ~ *(1103515245) & mask; // "linear congruential"
	RANDMAX	= 2147483647.0; // = 2^31-1 = MAX_SIGNED_INT in 32 bits
};

// random : random truth test: r = chance that random will produce "1", b = trigger the random calculation
random(chance,trigger,seed) = randomnoise(32,seed) : <(chance) : ba.sAndH((trigger : ba.impulsify)) : *(trigger);

//chaos: generates a continuous or triggered random values between 0 and 1 and adds it to the incoming signal
// chaos(value,seed,trigact,trig) = _ : +(randomnoise(8,seed) <: _,ba.sAndH(trig : ba.impulsify) : ba.selectn(2,trigact) : *(value) : si.smoo) : min(1,_) : max(0,_) : _;
chaos(value,seed,trigact,trig) = _ : +(randomnoise(8,seed) : *(value) <: (_,(_ : ba.sAndH(trig : ba.impulsify)) : si.interpolate(trigact)) : si.smoo) : min(1,_) : max(0,_) : _;
