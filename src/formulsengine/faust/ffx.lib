declare author "James Dooley: info@formuls.co.uk";
declare copyright "James Dooley";
declare version "1.0";
declare license "MIT";
declare options "[osc:on]";

import("stdfaust.lib");

//--- places all the fx below into a signal chain. This is formuls specific.
fx = _ <: _,(am : chorus : bitcrush : saturation : filter : delay : gate) : si.interpolate(fxsend);

fxsend = fxs
with {
  fxs = hslider("fxsend",1,0,1,0.01);
};

//----------------------------------------------------------------------------------------//
//---------------------------------------FX_FUNCTIONS-------------------------------------//
//----------------------------------------------------------------------------------------//
//------AMPLITUDE_MODULATION-----//
am = _ : *(1-(amd *(amf : amosc)))
with{
  amw = hslider("amwave",0,0,1,0.001) : *(3);
  amf = hslider("amfreq",0,0,1,0.001) : *(99.9) : max(0.1) : si.smoo;
  amd = hslider("amdepth",0,0,1,0.01) : si.smoo;

  clip(x) = x : min(1,_) : max(0,_);
  amosc = _ <: (((((os.oscsin : *(0.5) : +(0.5)), os.lf_trianglepos : si.interpolate(clip(amw))), os.lf_sawpos : si.interpolate(clip(amw-(1)))), os.lf_squarewavepos : si.interpolate(clip(amw-2))));
};
//-----------SATURATION---------------//
/* tanh waveshape distortion */
saturation = _ <: _,(_ : *(1.57) : ma.tanh) : si.interpolate(sat)
with{
  sat = hslider("saturation",0,0,1,0.01) : si.smoo;
};
//-----------RESONANT_FILTER---------------//
filter = _ : fi.highpass(2,hip) : fi.resonlp(lop,res,1)
with {
  hip = hslider("highpass",0,0,1,0.001) : *(136) : ba.midikey2hz : si.smoo;
  lop = hslider("lowpass",1,0,1,0.001)  : *(135) : ba.midikey2hz : si.smoo;
  res = hslider("filterresonance",0,0,1,0.001) : *(99) : +(1) : si.smoo;
};
//-----------BITCRUSHER---------------//
bitcrush = _ : ba.downSample(bit)
with {
  bit = hslider("bitcrush",0,0,1,0.01) : 1-(_) : *(47950) : +(50) : si.smoo;
};
//------------PITCHSHIFT------------//
pitchshift = _ : ef.transpose(300,50,pit) //
with {
  pit = hslider("pitchshift",0.5,0,1,0.1) : *(48) : -(24) : si.smoo;
};
//-------------DELAY---------------//
//interpolated delay with reverse function
delay = _ <: (_,lagrangedelay :> _),(_,reversedelay : si.interpolate(ds)) : si.interpolate(dlr)
with {
  N	= int(2^17);

  ds = hslider("delaysend",0,0,1,0.01) : si.smoo;
  dt = hslider("delaytime",0,0,1,0.01);
  df = hslider("delayfeedback",0,0,1,0.01) : si.smoo;
  dlr = checkbox("delayreverse") : int;

  dtlag = dt*(ma.SR) : si.smoo;
  dtrevpre = dt : *(5) : +(12) : int;
  dtrev = 2^(dtrevpre) : int;

  lagrangedelay = *(ds) : (+ :de.sdelay(N, 24, dtlag)) ~ *(df);
  reversedelay = _ : (+ : (ef.reverseDelayRamped(dtrev,0))) ~ *(df);
};
//-------------CHORUS-------------//
// courtesy of Albert Graef, simplified by formuls
chorus(x) = x+level*de.fdelay(1<<16, t, x)
with {
  depth	= hslider("chorus",0,0,1,0.01) : si.smoo;

  level	= depth > 0 : si.smoo;
  freq	= os.osc(1) : *(0.5) : +(0.25);
  dtime	= 0.02;

  t = ma.SR*dtime/2*(1+depth*tblosc(1<<16, sin, freq, 0));

  tblosc(n,f,freq,mod) = (1-d)*rdtable(n,wform,i&(n-1)) + d*rdtable(n,wform,(i+1)&(n-1))
  with {
      wform = ba.time*(2.0*ma.PI)/n : f;
      phase = freq/ma.SR : (+ : ma.decimal) ~ _;
      modphase = ma.decimal(phase+mod/(2*ma.PI))*n;
      i = int(floor(modphase));
      d = ma.decimal(modphase);
  };
};
//-------------GATE---------------//
gate = _ : ef.gate_mono(gt,ga,gh,gr) : _
with {
  gt = hslider("gatethresh",0,0,1,0.01) : *(60) : -(60); //short = gt
  ga = hslider("gateattack",0.001,0,1,0.01) : *(0.25) : +(0.001); // short = ga
  gh = hslider("gatehold",0,0,1,0.01) : *(0.25) : +(0.001); // short = gh
  gr = hslider("gaterelease",0,0,1,0.01) : +(0.001); // short = gr
};
//------ENVELOPE_FOLLOWER/SIDECHAIN----//
envelopefollower = _ : max(-1) : min(1) : an.amp_follower_ar(0.01, enveloperelease) <: env, side : ba.selectn(2,envelopeside) : _
with{
  enveloperelease = hslider("enveloperelease",0.001,0.001,1,0.001) : *(0.999) : +(0.001) : si.smoo;
  envelopedepth = hslider("envelopedepth",0,0,1,0.01) : si.smoo;
  envelopeside = checkbox("envelopeside");
  env = *(envelopedepth) : +(1-envelopedepth); // envelope follow algorithm
  side = 1-(_) *(envelopedepth); // sidechain algorithm
};
//------PANNING----//
panner = _ : sp.panner(pan)
with{
    pan = hslider("panning",0.5,0,1,0.01) : si.smoo;
};

//----------------------------------------//
//-------------MASTER BUS FX--------------//
//----------------------------------------//

//-------------REVERB-------------//
// Oneknob stereo reverb
reverb = sp.stereoize(fi.lowpass(1,3100) : fi.highpass(1,100)) <: re.fdnrev0(MAXDELAY,DELAYS,BSO,FREQS,DURS,duration,NONL) :> sp.stereoize(*(gain))
with{
  N = 16; 	// Feedback Delay Network (FDN) order (power of 2, 2 to 16)
  NB = 7; 	// Number of T60-controlled frequency-bands (3 or more)
  BSO = 3;	// Order of each lowpass/highpass bandsplit (odd positive integer)

  MAXDELAY = 8192; // sync w delays and prime_power_delays above
  DECAYTIME = 98.769;
  DURS = (DECAYTIME,DECAYTIME*(0.892),DECAYTIME*(0.713),DECAYTIME*(0.521),DECAYTIME*(0.301),DECAYTIME*(0.249),DECAYTIME*(0.113)); // Calculate delay times for each freq band
  FREQS = (250,500,1000,2000,4000,8000); // NB-1 default crossover frequencies (Hz)
  SHAPE = 1.7; // early reflections: location of closest wall
  LATE = SHAPE+(10.108); // late reflections: location of farthest away wall
  DELAYS = de.prime_power_delays(N,SHAPE,LATE);
  NONL = 0.913; // reverb  non-linearity setting.

  // shape = hslider("shape",20,0.1,63,0.1) : si.smoo;
  duration = hslider("duration",0.5,0,1,0.01) : *(0.1) : +(0.9) : si.smoo;
  gain = hslider("gain",0,0,1,0.01) :  *(0.25) : si.smoo;
};

//------------LIMITER-----------//
// "Oneknob" limiter for all your buss smashing needs
limiter = monolimiter
with {
  ceiling = 0.9;
  drylevel = hslider("drylimiterlevel",1,0,1,0.01) : si.smoo;
  limlevel = hslider("limiterlevel",0,0,1,0.01) : si.smoo;

  monolimiter = _ <: (_ : @(240): *(drylevel)),(*(100) : co.limiter_lad_N(1,0.005,ceiling,0.001,0.03,0.04) : *(limlevel)) :> _;
};

//------------DJEQ-----------//
// 3 band dj-style EQ.
djfilter = djlop : djhip
with{
  fc = hslider("djfiltercutoff",0.5,0,1,0.01) : si.smoo;
  r = hslider("djfilterresonance",1,1,100,1) : si.smoo;

  fh = fc : -(0.6) : max(0) : *(2.5) : pow(2.7) : *(5000) : +(5); // scales "filtercutoff" values between 0.6-1 to lie between 5-5000Hz (high pass)
  fl = fc : *(2.5) : min(1) : pow(2.7) : *(9980) : +(80); // scales "filtercutoff" values between 0-0.4 to lie between 80-10060Hz (low pass)
  djhip = fi.resonhp(fh,r,1);
  djlop = fi.resonlp(fl,r,1);
};

//------------REPEATER------//
// Glitchy tempo-synchronised repeater effect.
// Two delayensembles act like "voices", ensuring audio is always present in a delay line and captured immediately after the capture button has been released
repeater = _ <: par(i,2,((delayensemble(i), _*(parallel) :> _))) :> _
with {
  tempo = hslider("bpm",120,1,240,1) : 60/(_) : ba.sec2samp(_); // global tempo
  div = hslider("beatdivision",1,1,5,1) : int; //sample/capture duration in beats
  level = hslider("level",1,0,1,0.01) : pow(2.7) : si.smoo; // effect level
  cap = button("capture"); // capture some sound!
  parallel = checkbox("parallel") : +(1-(cap)) : min(1); // chooses between: incoming signal or capture signal; or incoming signal and captured signal.

  capcount = +(1)~(ba.sAndH(cap : ba.impulsify)) : %(2) : int;
  delayvoice(i,d,x) = _*(x != capcount) : (+ : de.sdelay(96000,1024,tempo/(d))) ~ *((x == capcount)*(cap)) : *(i==div) : *(x == capcount); //i = instance, d = beat division, j = incoming instance number(truth test)
  delayensemble(x) = _ <: delayvoice(1,1,x), delayvoice(2,2,x), delayvoice(3,4,x), delayvoice(4,8,x), delayvoice(5,16,x) :> _ : *(cap) : *(level);
};
